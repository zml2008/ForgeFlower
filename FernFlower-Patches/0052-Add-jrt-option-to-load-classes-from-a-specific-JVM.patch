From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: zml <zml@stellardrift.ca>
Date: Sat, 2 Apr 2022 23:57:57 -0700
Subject: [PATCH] Add jrt option to load classes from a specific JVM

This allows decompiling classes targeting any Java version while running on a Java 17 JVM

diff --git a/README.md b/README.md
index 225b42bcbd388c395fe51d2c5edda8d1cb1127b2..65a07c7d2ca1e906f0bc5d7ea6bd221515c582cd 100644
--- a/README.md
+++ b/README.md
@@ -66,6 +66,7 @@ The rest of options can be left as they are: they are aimed at professional reve
 - nls (0): define new line character to be used for output. 0 - '\r\n' (Windows), 1 - '\n' (Unix), default is OS-dependent
 - ind: indentation string (default is 3 spaces)
 - log (INFO): a logging level, possible values are TRACE, INFO, WARN, ERROR
+- jrt (): The path to a java runtime to add to the classpath, or `1` or `current` to add the java runtime of the active JVM to the classpath.
 
 ### Renaming identifiers
 
diff --git a/src/org/jetbrains/java/decompiler/main/Fernflower.java b/src/org/jetbrains/java/decompiler/main/Fernflower.java
index a9cb134d0e7907472b1abde8dd4fcbe4383dc4cc..a7a1a48ac004c25e5d578a2624c1f477a9d9936c 100644
--- a/src/org/jetbrains/java/decompiler/main/Fernflower.java
+++ b/src/org/jetbrains/java/decompiler/main/Fernflower.java
@@ -93,7 +93,14 @@ public class Fernflower implements IDecompiledData {
     logger.writeMessage(String.format("JVM info: %s - %s - %s", vendor, javaVersion, jvmVersion), IFernflowerLogger.Severity.INFO);
 
     if (DecompilerContext.getOption(IFernflowerPreferences.INCLUDE_ENTIRE_CLASSPATH)) {
-      ClasspathScanner.addAllClasspath(structContext);
+      ClasspathScanner.addAllClasspath(structContext, false);
+    } else if (!DecompilerContext.getProperty(IFernflowerPreferences.INCLUDE_JAVA_RUNTIME).toString().isEmpty()) {
+      final String javaRuntime = DecompilerContext.getProperty(IFernflowerPreferences.INCLUDE_JAVA_RUNTIME).toString();
+      if (javaRuntime.equalsIgnoreCase("current") || javaRuntime.equalsIgnoreCase("1")) {
+        ClasspathScanner.addAllClasspath(structContext, true);
+      } else {
+        ClasspathScanner.addRuntime(structContext, new File(javaRuntime));
+      }
     }
   }
 
diff --git a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
index 23ed017fc66747daf2f7b603df7d123835145570..a72ad0aba0523cd803b4832b9e95d7f67c8d1d7c 100644
--- a/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
+++ b/src/org/jetbrains/java/decompiler/main/extern/IFernflowerPreferences.java
@@ -35,6 +35,7 @@ public interface IFernflowerPreferences {
   String IGNORE_INVALID_BYTECODE = "iib";
   String VERIFY_ANONYMOUS_CLASSES = "vac";
 
+  String INCLUDE_JAVA_RUNTIME = "jrt";
   String INCLUDE_ENTIRE_CLASSPATH = "iec";
   String EXPLICIT_GENERIC_ARGUMENTS = "ega";
   String INLINE_SIMPLE_LAMBDAS = "isl";
@@ -92,6 +93,7 @@ public interface IFernflowerPreferences {
     defaults.put(IGNORE_INVALID_BYTECODE, "0");
     defaults.put(VERIFY_ANONYMOUS_CLASSES, "0");
 
+    defaults.put(INCLUDE_JAVA_RUNTIME, "");
     defaults.put(INCLUDE_ENTIRE_CLASSPATH, "0");
     defaults.put(EXPLICIT_GENERIC_ARGUMENTS, "0");
     defaults.put(INLINE_SIMPLE_LAMBDAS, "1");
diff --git a/src/org/jetbrains/java/decompiler/util/ClasspathScanner.java b/src/org/jetbrains/java/decompiler/util/ClasspathScanner.java
index 0cdeb5bbd8581965a96211dabc17bc18f3cde687..c0d96578d5c74abfd8deb3537e9f4a6799099a0b 100644
--- a/src/org/jetbrains/java/decompiler/util/ClasspathScanner.java
+++ b/src/org/jetbrains/java/decompiler/util/ClasspathScanner.java
@@ -2,13 +2,23 @@
 package org.jetbrains.java.decompiler.util;
 
 import java.lang.module.*;
+import java.net.URI;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.util.ArrayDeque;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Deque;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
+import java.util.stream.Stream;
 
 import org.jetbrains.java.decompiler.main.DecompilerContext;
 import org.jetbrains.java.decompiler.main.extern.IContextSource;
@@ -18,9 +28,9 @@ import org.jetbrains.java.decompiler.struct.StructContext;
 
 public class ClasspathScanner {
 
-    public static void addAllClasspath(StructContext ctx) {
-      Set<String> found = new HashSet<String>();
-      String[] props = { System.getProperty("java.class.path"), System.getProperty("sun.boot.class.path") };
+    public static void addAllClasspath(StructContext ctx, boolean bootOnly) {
+      Set<String> found = new HashSet<>();
+      String[] props = { bootOnly ? null : System.getProperty("java.class.path"), System.getProperty("sun.boot.class.path") };
       for (String prop : props) {
         if (prop == null)
           continue;
@@ -38,34 +48,93 @@ public class ClasspathScanner {
         }
       }
 
-      addAllModulePath(ctx);
+      addAllModulePath(ctx, bootOnly);
     }
 
-    private static void addAllModulePath(StructContext ctx) {
-      for (ModuleReference module : ModuleFinder.ofSystem().findAll()) {
-        String name = module.descriptor().name();
+    // https://openjdk.java.net/jeps/220 for runtime image structure and JRT filesystem
+
+    private static void addAllModulePath(StructContext ctx, boolean bootOnly) {
+      final var finder = ModuleFinder.ofSystem();
+      if (bootOnly) {
+        final ModuleReference ref = finder.find("java.se").orElseThrow(() -> new IllegalStateException("Could not find java.se module required by spec"));
+        final Set<String> seen = new HashSet<>();
+        final Deque<ModuleReference> toVisit = new ArrayDeque<>();
+        toVisit.add(ref);
+        ModuleReference current;
+        while ((current = toVisit.poll()) != null) {
+          if (!seen.add(current.descriptor().name())) {
+            continue;
+          }
+
+          for (var requires : ref.descriptor().requires()) {
+            var module = finder.find(requires.name()).orElse(null);
+            if (module == null && !requires.modifiers().contains(ModuleDescriptor.Requires.Modifier.STATIC)) {
+              DecompilerContext.getLogger().writeMessage("Could not find Java SE component " + requires.name(), IFernflowerLogger.Severity.ERROR);
+              continue;
+            }
+            toVisit.add(module);
+          }
+
+          try {
+            ctx.addSpace(new ModuleContextSource(current), false);
+          } catch (IOException e) {
+            DecompilerContext.getLogger().writeMessage("Error loading module " + current.descriptor().name(), e);
+          }
+        }
+      } else {
+        for (ModuleReference module : finder.findAll()) {
+          String name = module.descriptor().name();
+          try {
+            ctx.addSpace(new ModuleContextSource(module), false);
+          } catch (IOException e) {
+            DecompilerContext.getLogger().writeMessage("Error loading module " + name, e);
+          }
+        }
+      }
+    }
+
+    public static void addRuntime(final StructContext ctx, final File javaHome) {
+      if (new File(javaHome, "lib/jrt-fs.jar").isFile()) {
+        // Java 9+
         try {
-          ctx.addSpace(new ModuleContextSource(module), false);
-        } catch (IOException e) {
-          DecompilerContext.getLogger().writeMessage("Error loading module " + name, e);
+          ctx.addSpace(new JavaRuntimeContextSource(javaHome), false);
+        } catch (final IOException ex) {
+          DecompilerContext.getLogger().writeMessage("Failed to open java runtime at " + javaHome, ex);
         }
+        return;
+      } else if (javaHome.exists()) {
+        // legacy runtime, add all jars from the lib and jre/lib folders
+        boolean anyAdded = false;
+        final List<File> jrt = new ArrayList<>();
+        Collections.addAll(jrt, new File(javaHome, "jre/lib").listFiles());
+        Collections.addAll(jrt, new File(javaHome, "lib").listFiles());
+        for (final File lib : jrt) {
+          if (lib.isFile() && lib.getName().endsWith(".jar")) {
+            ctx.addSpace(lib, false);
+            anyAdded = true;
+          }
+        }
+        if (anyAdded) return;
       }
+
+      // does not exist
+      DecompilerContext.getLogger().writeMessage("Unable to detect a java runtime at " + javaHome, IFernflowerLogger.Severity.WARN);
     }
 
-    static class ModuleContextSource implements IContextSource, AutoCloseable {
-      private final ModuleReference ref;
-      private final ModuleReader reader;
+    static abstract class ModuleBasedContextSource implements IContextSource {
+      private final ModuleDescriptor ref;
 
-      public ModuleContextSource(final ModuleReference ref) throws IOException {
+      public ModuleBasedContextSource(final ModuleDescriptor ref) {
         this.ref = ref;
-        this.reader = ref.open();
       }
 
       @Override
       public String getName() {
-        return "module " + this.ref.descriptor().toNameAndVersion();
+        return "module " + this.ref.toNameAndVersion();
       }
 
+      protected abstract Stream<String> entryNames() throws IOException;
+
       @Override
       public Entries getEntries() {
         final List<String> classNames = new ArrayList<>();
@@ -73,7 +142,7 @@ public class ClasspathScanner {
         final List<String> otherEntries = new ArrayList<>();
 
         try {
-          this.reader.list().forEach(name -> {
+          this.entryNames().forEach(name -> {
             if (name.endsWith("/")) {
               directoryNames.add(name.substring(0, name.length() - 1));
             } else if (name.endsWith(CLASS_SUFFIX)) {
@@ -88,6 +157,20 @@ public class ClasspathScanner {
 
         return new Entries(classNames, directoryNames, otherEntries);
       }
+    }
+
+    static class ModuleContextSource extends ModuleBasedContextSource implements AutoCloseable {
+      private final ModuleReader reader;
+
+      public ModuleContextSource(final ModuleReference ref) throws IOException {
+        super(ref.descriptor());
+        this.reader = ref.open();
+      }
+
+      @Override
+      public Stream<String> entryNames() throws IOException {
+        return this.reader.list();
+      }
 
       @Override
       public InputStream getInputStream(String resource) throws IOException {
@@ -99,4 +182,74 @@ public class ClasspathScanner {
         this.reader.close();
       }
     }
+
+    static final class JavaRuntimeModuleContextSource extends ModuleBasedContextSource {
+      private Path module;
+
+      JavaRuntimeModuleContextSource(final ModuleDescriptor descriptor, final Path moduleRoot) {
+        super(descriptor);
+        this.module = moduleRoot;
+      }
+
+      @Override
+      public InputStream getInputStream(String resource) throws IOException {
+        return Files.newInputStream(this.module.resolve(resource));
+      }
+
+      @Override
+      protected Stream<String> entryNames() throws IOException {
+        try (final var dir = Files.walk(this.module)) {
+          return dir.map(it -> this.module.relativize(it).toString()).toList().stream();
+        }
+      }
+    }
+
+    static final class JavaRuntimeContextSource implements IContextSource, AutoCloseable {
+      private final File javaHome;
+      private final FileSystem jrtFileSystem;
+
+      public JavaRuntimeContextSource(final File javaHome) throws IOException {
+        this.javaHome = javaHome;
+        final var url = URI.create("jrt:/");
+        this.jrtFileSystem = FileSystems.newFileSystem(url, Map.of("java.home", javaHome.getAbsolutePath()));
+      }
+
+      @Override
+      public String getName() {
+        return "Java runtime " + this.javaHome.getAbsolutePath();
+      }
+
+      @Override
+      public Entries getEntries() {
+        // One child source for every module in the runtime
+        final List<IContextSource> children = new ArrayList<>();
+        try {
+        final List<Path> modules = Files.list(this.jrtFileSystem.getPath("modules")).toList();
+        for (final Path module : modules) {
+          ModuleDescriptor descriptor;
+          try (final InputStream is = Files.newInputStream(module.resolve("module-info.class"))) {
+            descriptor = ModuleDescriptor.read(is);
+          } catch (final IOException ex) {
+            continue;
+          }
+          children.add(new JavaRuntimeModuleContextSource(descriptor, module));
+        }
+
+          return new Entries(List.of(), List.of(), List.of(), children);
+        } catch (final IOException ex) {
+          DecompilerContext.getLogger().writeMessage("Failed to read modules from runtime " + this.javaHome, ex);
+          return Entries.EMPTY;
+        }
+      }
+
+      @Override
+      public InputStream getInputStream(String resource) throws IOException {
+        return null; // all resources are part of a child provider
+      }
+
+      @Override
+      public void close() throws IOException {
+        this.jrtFileSystem.close();
+      }
+    }
 }
